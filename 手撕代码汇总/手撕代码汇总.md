# 手撕代码汇总

## 1. 数组中找出所有重复数字，要求空间复杂度为O(1)，时间复杂度最小？

可先将数组进行排序，这样所有重复的数字就会聚集在一起，再正向遍历一遍即可找出重复的数字。

```java
Arrays.sort(nums);// nums 是给定的数组
for(i=1;i<nums.length;i++){
    if(nums[i]==nums[i-1]){
        System.out.println(nums[i]);
    }
}
```

## 2. 求链表的中点（或求K等分点）？

使用两个指针：快指针每次走K步，慢指针每次走1步。快、慢指针同时出发，快指针到达终点的时刻，慢指针所停留的位置即是K等分点。

证明：

```
假设快指针速度为 fast=K,慢指针速度为 slow=1。路长度为 S。
则同时发出，快指针到达终点所用时间为 t=S/K。
这段时间内慢指针行走的距离为 1*t = S/K.
```

给出求链表中点的代码：

```java
public ListNode middleNode(ListNode head){
    if(head==null || head.next==null) return head;
    ListNode walker=head,runner=head;
    while(runner!=null && runner.next!=null){
        walker = walker.next;
        runner = runner.next.next;
    }
    return walker;
}
```

## 3. 手写常用设计模式（单例）

### 3.1 懒汉式，线程不安全

```java
public class Singleton {  
    private static Singleton instance;  
    private Singleton (){}  

    public static Singleton getInstance() {  
    if (instance == null) {  
        instance = new Singleton();  
    }  
    return instance;  
    }  
}
```

### 3.2 懒汉式，线程安全

```java
public class Singleton {  
    private static Singleton instance;  
    private Singleton (){}  
    
    public static synchronized Singleton getInstance() {  
    if (instance == null) {  
        instance = new Singleton();  
    }  
    return instance;  
    }  
}
```

### 3.3 饿汉式，线程安全

```java
public class Singleton {  
    private static Singleton instance = new Singleton();  
    private Singleton (){}  
    public static Singleton getInstance() {  
    return instance;  
    }  
}
```

### 3.4 双重校验锁（DCL，即 double-checked locking）

```java
public class Singleton {  
    private volatile static Singleton singleton;  
    private Singleton (){}  
    public static Singleton getSingleton() {  
    if (singleton == null) {  
        synchronized (Singleton.class) {  
        if (singleton == null) {  
            singleton = new Singleton();  
        }  
        }  
    }  
    return singleton;  
    }  
}
```

需要在单例实例加上 ```volatile```修饰，防止由于指令重排序而导致其他线程使用到了半初始化的对象实例。

解释指令重排序的影响。

源码：

```java
class T{
    int m=8;
}
T t = new T();
```

对应的字节码：

```java
0 new #2 <test/T>
3 dup
4 invokespecial #3 <test/T.<init>>
7 astore_1
8 return
```

```0 new #2 <test/T>```表示新建一个对象，新建完成后处于半初始化状态。```m=0```。

```4 invokespecial #3 <test/T.<init>> ``` 表示调用初始化函数，即构造函数。```m=8```。

``` 7 astore_1``` 表示将线程栈上的 ```t```变量指向堆中的对象。

其中 ``` 4 invokespecial #3 <test/T.<init>>``` 和 ``` 7 astore_1```可能会发生指令重排序，导致先执行引用链接再执行初始化，这样其他线程就有可能会获取到一个处于半初始化状态的对象。

因此，必须需要加以 ```volatile```修饰，防止指令重排。

## 4. 手写生产者消费者模式

http://blog.csdn.net/monkey_d_meng/article/details/6251879/

## 5. 100个0到100之间的整数排序

可以使用基于桶排序思想的计数排序，计算排序是非比较的排序。

适用范围：**数据量大但范围小**。

计数排序存在问题：不稳定。

解决：对频次数组进行前缀和操作，再对原数组逆向遍历。

```java
int[] sort(int[] arr){ // 返回稳定的排序结果
    int[] result = new int[arr.length];
    int[] count = new int[10];
    for(int i=0;i<arr.length;i++){
        count[arr[i]]++;
    }
    
    for(int i=1;i<count.length;i++){
        count[i] +=count[i-1];
    }
    for(int i=arr.length-1;i>=0;i--){
        result[--count[arr[i]]] = arr[i];
    }
    return result;
}
```

## 6. two sum 问题到k sum 问题

**two sum**

```java
public class Solution {
    /**
     * @param numbers: An array of Integer
     * @param target: target = numbers[index1] + numbers[index2]
     * @return: [index1, index2] (index1 < index2)
     */
    public int[] twoSum(int[] numbers, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        
        for(int i=0;i<numbers.length;i++){
           
            if(map.containsKey(target-numbers[i])){
                return new int[]{map.get(target-numbers[i]),i};
            }else if(!map.containsKey(numbers[i])){
                map.put(numbers[i],i);
            }
        }
        return new int[]{0,0};
    }
}
```

**k sum**

```java
public class Solution {
    /**
     * @param A: An integer array
     * @param k: A positive integer (k <= length(A))
     * @param target: An integer
     * @return: An integer
     */
    public int kSum(int[] A, int k, int target) {
        int n = A.length;
        int[][][] f=new int[n+1][k+1][target+1];
        // f[i][j][t] 表示从数组的前i个数中选择j个数组成和为t的组合数
        
        for(int i=0;i<=n;i++){
            for(int j=0;j<=k;j++){
                for(int t=0;t<=target;t++){
                    if(i==0&&j==0&&t==0){
                        f[i][j][t]=1;
                    }else if(i==0){
                        f[i][j][t]=0;
                    }else{
                        if(j-1>=0&&t-A[i-1]>=0){
                            f[i][j][t]=f[i-1][j][t]+f[i-1][j-1][t-A[i-1]];
                        }else{
                            f[i][j][t]=f[i-1][j][t];
                        }
                    }
                }
            }
        }
        return f[n][k][target];
    }
}
```

## 7. 算 a+b ，不能用加号或减号

```java
int add(int a, int b){
    int c=a & b, r=a ^ b;
    return c == 0 ? r : add(r,c<<1);
}
```

## 8. 求数组中超过一半的数

**摩尔投票算法**（抵消算法）

基本思想，在每一轮投票过程中，从数组中找出一对不同的元素，将其从数组中删除（称为**抵消**）。这样不断地删除直到无法再进行投票，如果数组为空，则没有任何元素出现的次数超过该数组长度的一半，如果只存在一种元素，那么这个元素就是所要求的众数。

```java
public class Solution {
    /*
     * @param nums: a list of integers
     * @return: find a  majority number
     */
    public int majorityNumber(List<Integer> nums) {
        int count=0;
        int res=0;
        for(Integer num : nums){
            if(count==0){
                res=num;
                count++;
            }else{
                if(res==num) count++;
                else count--;
            }
        }
        return res;
    }
}
```

## 9. 100亿数据中找出最大的1000个数字（top K 问题）

https://blog.csdn.net/zyq522376829/article/details/47686867

https://blog.csdn.net/sofuzi/article/details/80825197

## 10. 两个有序数组，求第K个数

直接用归并排序求到第K个数即可。

一道相似的题目：

### [65. Median of two Sorted Arrays](https://www.lintcode.com/problem/median-of-two-sorted-arrays/description)

There are two sorted arrays *A* and *B* of size *m* and *n* respectively. Find the **median** of the two sorted arrays.

```java
public class Solution {
    /*
     * @param A: An integer array
     * @param B: An integer array
     * @return: a double whose format is *.5 or *.0
     */
    public double findMedianSortedArrays(int[] A, int[] B) {
        int n=A.length+B.length;
        boolean odd = n%2!=0 ? true : false;
      
        int[] C = new int[n];
        int index=0,a=0,b=0;
        while(index<=n/2&&a<A.length&&b<B.length){
            C[index++] = A[a] < B[b] ? A[a++] : B[b++];
        }
        while(index<=n/2&&a<A.length){
            C[index++] = A[a++];
        }
        while(index<=n/2&&b<B.length){
            C[index++] = B[b++];
        }
        
        if(odd){
            return (double)C[index-1];
        }
        
        return (double)(C[index-1]+C[index-2])/2;
    }
}
```

## 11. 最大连续子数组和

### [41. Maximum Subarray](https://www.lintcode.com/problem/maximum-subarray/description)

Given an array of integers, find a contiguous subarray which has the largest sum.

```java
public class Solution {
    /**
     * @param nums: A list of integers
     * @return: A integer indicate the sum of max subarray
     */
    public int maxSubArray(int[] nums) {
        int n = nums.length;
        int[] f=new int[n];
        f[0]=nums[0];
        int maxVal = f[0];
        for(int i=1;i<nums.length;i++){
            f[i]=nums[i];
            f[i]=Math.max(f[i],f[i-1]+nums[i]);
            maxVal=Math.max(maxVal,f[i]);
        }
        return maxVal;
    }
}
```

## 12. 手写快速排序算法，并解释其过程



## 13. 重建二叉树



## 14. 二分查找



## 15. 从字符串中 "aecbcda"找出不重复的字符组成的顺序子串"aecbd"，用最优的时空复杂度。



## 16. 判断一个链表是否有环



## 17.一个数组，有正有负，把正的移到右边，负的移到左边。



## 18. 两个队列实现栈



## 19. 括号匹配



## 20. 链表反转

**Approach #1(Recursive)**

```java
public ListNode reverseList(ListNode head){
    if(head == null || head.next == null) return head;
    ListNode p = reverseList(head.next);
    head.next.next = head;
    head.next = null;
    return p;
}
```

**Approach #2(Iterative)**

```java
 public ListNode reverseList(ListNode head){
     ListNode prev = null;
     ListNode curr = head;
     while(curr != null){
         ListNode nextTemp = curr.next;
         curr.next = prev;
         prev = curr;
         curr = nextTemp;
     }
     return prev;
 }
```



## 21. 一个数组，实现原地反转



## 22. 一个只包含小写字母的字符串，去重后生成一个只包含单一字母的字符串。例如 "abadcab"变成"abdc"，只让用最多一个额外的 int 变量



## 23. 大数加法代码



## 24. 堆排序



## 25. 给一个字符串，由26个英文字母组成，判断其中有没有重复出现的元素，有返回true，没有返回 false。