# 百度三面



## 一、 在 Linux 下什么命令可以查看CPU每个核的逻辑状态？

如果要查看每个逻辑 CPU 的使用率，只需要运行 top 命令，按下数字键 1 即可。

## 二、 Redis 的 String 和 C 语言的String的区别

参考：https://blog.csdn.net/cjqh_hao/article/details/89741720

### 一、数据结构

redis 的字符器底层数据结构是 sds (simple dynamic string)，即简单动态字符串，其结构体定义如下：

```c
struct sdshdr {
    // buf 中已占用空间的长度
    int len;
    // buf 中剩余可用空间的长度
    int free;
    // 数据空间
    char buf[];
};

```

其中：

len: 当前实际存储的字符串长度；

free:剩余未使用的长度；

buf: 用于存储数据的字节数组；

```
     buf
-------|---------|
len	     free
```



SDS 遵循 C 语言字符串以空格符结尾的惯例，保存空字符的 1 字节空间不计算在 SDS 的 len 属性中，并且为空字符分配额外的 1 字节空间，以及添加空字符到字符串末性等操作，都有 SDS 函数自动完成。

而 C 语言中的字符串只是用字符数组来表示 。

### 二、复杂度问题

SDS 由于存储了 len 属性，所以获取字符长度的时间复杂度为 O(1)，而 C 字符串并不记录本身长度，故获取字符串长度需要遍历整个字符串，直到遇到空字符，时间复杂度 O(N)。SDS 的长度更新是有 SDS 的 API 自动完成的。

SDS 的设计是典型的利用空间换时间。

### 三、内存分配释放策略

概括为**预分配** + **惰性释放**

SDS 的内存分配策略：

1. 如果对 SDS 字符串修改后， len 的值小于 1MB时，free 与 len 保证同样的增长。例如，如果 SDS 的字符串长度修改为 15 字节，那么会分配 15 字节空间给 free, SDS 的 buf 属性长度为 15(len) + 15 (free) +1 (空字符) = 31 字节。

2. 如果 SDS 字符串修改后，len 大于等于 1MB，那么程序会分配 1MB 的空间给 free，例如， SDS 字符串长度修改为50MB 那么程序分配 1MB 的未使用空间给 free，SDS 的 buf 属性长度为 50 MB （len）+1MB（free）+ 1byte（空字符）。

   预分配策略有效减少了内存分配操作次数。

SDS的内存释放策略：

当需要缩短 SDS 字符串时，程序并不立刻将内存释放，而是使用 free 属性将这些空间记录下来，以备将来使用。

### 三、缓冲区溢出问题

SDS 的字符串的内存预分配策略能有效避免缓冲区溢出问题。

C 字符串每次操作增加长度时，都要分配足够长度的内存空间，否则就会产生缓冲区溢出（buffer overflow）。

### 四、二进制安全问题

SDS 字符串 API 都是处理二进制的方式处理 buf 数组，程序不会对其中的数据进行过滤、操作等，所以 SDS 是二进制数据安全的。

C 字符串的字符则必须符合某种编码（ASCII），并且字符串的中间不能包含空字符，否则字符串就会被截断，所以 C 字符串只能保存文本数据，而不能保存图片、音视频等数据类型。

## 三、有十亿个int 类型的数，查找其中是否存在一个特定的数？

**solution1:** 使用 bitmap 。第 1 个位表示 1 ，第 2 位表示 2，依次类推。 int 类型的最大范围为 21 亿以内，最多需要 21 亿个 bit 内存大小即可。

**solution2:** 使用 Bloom Filter （有一定的错误率）

**solution3:** 最差的方法，十亿的个 int 类型的数据大概只需要 4GB的内存，可以用JDK中的 Set 集合直接存储。

## 四、synchronized 关键字