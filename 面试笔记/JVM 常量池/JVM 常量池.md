# JVM 常量池

JVM 常量池主要分为 **Class 文件常量池、运行时常量池、全局字符串常量池、以及基本类型包装类对象常量池。**

## 1. Class 文件常量池

class 文件是一组以字节为单位的二进制数据流，在 java 代码的编译期间，我们编写的 `java` 文件就被编译为 `.class` 文件格式的二进制数据存放在磁盘中，其中就包括 `class` 文件常量池。 `class` 文件中存在常量池（非运行时常量池），其在编译阶段就已经确定，`JVM` 规范对 `class` 文件结构有着严格的规定，必须符合此规范的 `class` 文件才能被 `JVM` 装载。

class 文件常量池主要存放两大常量：**字面量和符号引用**。

1）字面量：字面量接近 java 语言层面的常量概念，主要包括：

* **文本字符串**：`public String s = "abc";` 中的 `"abc"`；
* **用 `final` 修饰的成员变量**： 包括静态变量、实例变量和局部变量；

2）符号引用：符号引用主要涉及编译原理方面的概念，主要包括：

* **类和接口的全限定名**： 也就是 `java/lang/String` 这样，将类名中原来的 `.` 替换为 `/` 得到， 主要用于在运行时解析得到类的直接引用。
* **字段的名称和描述符**：字段也就是类或者接口中声明的变量，包括类级别变量和实例级的变量。
* **方法中的名称和描述符**：也即参数类型 + 返回值

## 2. 运行时常量池

运行时常量池是方法区的一部分，所以也是全局贡献的，`JVM` 在执行某个类时，必须经过 **加载、链接（验证、准备、解析）、初始化**， 在第一步加载时需要完成：

* 通过一个类的全限定名来获取此类的二进制字节流；
* 将这个字节所代表的静态存储结构转化为方法区的运行时数据结构；
* 在内存中生成一个类对象，代表加载的这个类，这个对象是 `java.lang.Class`，它作为方法区这个类的各种数据访问的入口。

运行时常量池的作用是存储` java class` 文件常量池中的符号信息，运行时常量池中保存着一些 `class` 文件中描述符号引用，同时在类的解析阶段还会将这些**符号引用转化成直接引用**（直接指向实例对象的指针，内存地址），转化后的直接引用也是存储在运行时常量池中。

多个 class 文件中常量池相同的字符串，只会**存一份在运行时常量池**。

运行时常量池相对于 `class` 常量池一大特征就是具有**动态性**，`java` 规范并不要求常量只能在加载时才产生，也就是说运行时常量池的内容并不全部来自 class 常量池，在运行时可以通过代码生成生成常量并将其放入运行时常量池中，这种特性被用的最多的就是 `String.intern()`。

## 3. 全局字符串常量池

字符串常量池是 JVM 所维护的一个字符串实例的引用表， 在 HotSpot VM 中，它是一个叫做 StringTable 的全局表。在字符串常量池中维护的是字符串实例的引用，底层 C++ 实现就是一个 HashTable 。这些被维护的引用所指的字符串实例，被称作“被驻留的字符串” 或 “interned string” 或通常所说的 “进入了字符串常量池的字符串”。

**运行时常量池在方法区（Non-heap），而 JDK 1.7 后，字符串常量池被移到了 heap 区，两者根本就不是一个概念。**

## 参考

https://juejin.im/post/6854573216824819719

https://blog.csdn.net/qq_26222859/article/details/73135660

