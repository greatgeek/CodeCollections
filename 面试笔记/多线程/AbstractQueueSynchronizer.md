# AbstractQueueSynchronizer

```

+-----------------------------------------------------------+
|					Abstract Queue Synchronizer			 |
|		+------+									    |
|	    | state| atomic int							     |
|	    +------+										|
|													   |
|           +------+  prev +-----+       +-----+		   |
|      head |      | <---- |     | <---- |     |  tail	    |
|           +------+       +-----+       +-----+		   |
|													   |
+-----------------------------------------------------------+
```

## 一、同步队列原理

同步器依赖内部的**同步队列**（FIFO）来完成**同步状态**的管理。若当前线程去获取同步状态成功时，则可以继续执行。若当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成一个节点（Node）并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步状态。

## 二、同步器的使用

要使用这个同步器，需要重定义下列方法。

* 互斥模式

	* `tryAcquire()`
	* `tryRelease()`
* 共享模式
  * `tryAcquireShared()`
  * `tryReleaseShared()`
* `isHeldExclusively()` 若当前线程独占地持有同步器，则 `return true`。

## 三、基于AQS实现公平锁与非公平锁

当A线程拥有锁时，`state>0`，B线程尝试获取锁时，会对这个 `state` 有一个 `CAS(0,1)`的操作，尝试几次失败后，就挂起线程，进入等待队列。（同步器将其进入同步队列）

若A线程执行完成释放了锁，`state=0`， 同步器会唤醒同步队列中的首节点，假设为B线程，B线程被唤醒后，会检查 `state` ，进行`CAS(0,1)` 操作，此时若C线程也尝试去争抢这把锁。

* 非公平锁的实现

  C直接尝试对这个 `state` 进行`CAS(0,1)`操作，并成功改变了 `state`, 则C线程会在B线程之前获得锁。

* 公平锁的实现

  C发现有线程在同步队列，则将自己进入同步队列并挂起，B获得锁。（实际上是同步器会将C线程加入同步队列，唤醒B线程去尝试获得锁）

## 参考

JDK文档 AbstractQueueSynchronizer