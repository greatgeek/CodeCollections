# Redis 缓存穿透、击穿、雪崩

## Redis 缓存雪崩

缓存雪崩指的是缓存层大面积的数据同时失效，所有的请求都涌向的数据库。

![img](https://user-gold-cdn.xitu.io/2019/11/3/16e30d2c5e17899c?imageView2/0/w/1280/h/960/ignore-error/1)

同一时间大面积失效，那一瞬间Redis 跟没有一样，那这个数量级别的请求直接打到数据库几乎是灾难性的。

### 解决缓存雪崩的方法

处理缓存雪崩的方法，在批量向 Redis 存数据时，把每个Key 的失效时间都加个随机值就好了，这样可以保证数据不会在同一时间大面积失效。

```
setRedis（Key，value，time + Math.random() * 10000）;
```

如果 Redis 是集群部署，将热点数据均匀分布在不同的 Redis 库中也能避免全部失效的问题，但是往往在生产环境中操作集群时，单个服务都是对应的单个 Redis 分片，是为了方便数据的管理，但是也同样有了可能会失效的弊端，失效时间随机是个好策略。

歌者设置热点数据永远不过期，有更新操作就更新缓存就好了，电商首页的数据也可以用这个操作。

## Redis 缓存穿透

缓存穿透指用户请求缓存和数据库中都没有的数据，这时请求必然会打向数据库。此时的用户很可能是攻击者，攻击会导致数据库压力过大，严重会击垮数据库。

![img](https://user-gold-cdn.xitu.io/2019/11/3/16e30d1847df0faf?imageView2/0/w/1280/h/960/ignore-error/1)

我们的数据库的 id 都是 1 开始自增上去的，假如发起 id 值为 -1 的数据或 id 为特别大且不存在的数据，就会造成缓存穿透。

若不对参数做校验，数据库 id 都是大于0的，我一直用小于 0 的参数去请求，每次都能绕开 Redis 直接打到数据库上，数据库也查不到，每次都这样，并发高点就容易崩掉了。

### 解决缓存穿透的方法

* 可以在接口层增加校验，比如用户鉴权校验，参数校验，不合法的参数直接返回，比如： id 做基础校验， id <=0 的直接拦截。
* 从缓存取不到的数据，在数据库中也没有取到，这时也可以将对应 Key 的Value 写为 null, 缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。
* 若是攻击用户反复用同一个 id 暴力攻击，正常用户是不会在单位时间内发起这么多次请求的，可以在网关层把这个 IP 拉黑。
* 在数据库前加上布隆过滤器（Bloom Filter），这个也能很好的防止缓存穿透的发生，他的原理也很简单就是利用高效的数据结构和算法快速判断出你这个Key 是否在数据库中存在，不存在就直接返回，存在就去查数据库，刷新缓存再返回。

## Redis 缓存击穿

缓存击穿跟缓存雪崩有点像，但又不太一样，缓存雪崩是因为大面积的缓存失效，打崩了DB，而缓存击穿不同的是缓存击穿是指一个 Key 非常热点，在不停的扛着高并发，高并发集中对这一个点进行访问，当这个Key 在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个完好无损的桶上凿开了一个洞。

### 解决缓存击穿的方法

* 使用互斥锁（mutex key），抢到锁的话读数据库并写入缓存，抢不到锁的话也不阻塞，而是直接去读缓存，如果缓存中仍然读不到数据（抢到锁的可能还没将缓存写入成功），就等一会再试试。
* 双缓存，设置一级缓存和二级缓存，一级缓存过期时间短，二级缓存过期时间长或者不过期，一级缓存失效后访问二级缓存，同时刷新一级缓存和二级缓存。

## 总结

一般避免以上情况发生我们从三个时间段去分析下：

* 事前：Redis 高可用，主从+哨兵， Redis cluster，避免全盘崩溃。
* 事中：本地 ehcache 缓存 + Hystrix 限流+降级，避免 MySQL 被打死。
* 事后：Redis 持久化 RDB + AOF，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。

## 参考

https://juejin.im/post/5dbef8306fb9a0203f6fa3e2