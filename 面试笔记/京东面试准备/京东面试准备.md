1、List和Set的区别  

  2、List常用的实现类  

  3、ArrayList和LinkedList的区别  

  4、Set常用的实现类  

HashSet，TreeSet，LinkedHashSet 

HashSet 是在 HashMap 的基础上建立起来的，HashSet存入的元素作为 HashMap 中的 Key 变量，其中Value 都为同一个值， 也就是一个 Object() 对象。

TreeSet 也是基于 TreeMap 实现的，支持两种排序方式：自然排序和自定义排序。两者的实现都使用的红黑树这种自平衡的排序二叉树，可以保证快速检索指定元素。

LinkedHashSet 直接继承了 HashSet ，其 add()/remove()/contains() 方法都没有重写，直接使用的是HashSet 中的。底层使用双向链表实现，可以维护插入元素的顺序。

  5、HashSet和LinkedHashSet的区别  

**HashSet**

HashSet有如下特点：

* 不能保证元素的排列顺序；
* 不是线程安全的；
* 集合元素可以是 null ，但只能放入一个 null。

当向HashSet 集合中存入一个元素时，HashSet 会调用该对象的 hashCode() 方法来得到该对象的 hashCode值， 然后根据 hashCode 值来决定该对象在 HashSet 中存储的位置。

简单地说，HashSet 集合判断两个元素相等的标准是两个对象通过equals 方法比较相等，并且两个对象的 hashCode() 方法返回值相等。

注意，如果要把一个对象放入 HashSet 中， 重写该对象的 equals 方法， 也应该重写其 hashCode() 方法。其规则是如果两个对象通过equals方法比较返回 true 时，其 hashCode 也应该相同。 另外，对象中用作 equals 比较标准的属性，都应该用来计算 hashCode 的值。

**LinkedHashSet**

LinkedHashSet 集合同样是根据元素的 hashCode 值来决定元素的存储位置， 但是它同时使用链表维护元素的次序。当遍历该集合时，可以以添加顺序输出。

LinkedHashSet 在迭代访问Set 中的全部元素时，性能比 HashSet 好，但是插入时性能比HashSet 差。

**TreeSet**

TreeSet 是 SortedSet 接口的唯一实现类，TreeSet 可以确保集合元素处于排序状态。TreeSet 支持两种排序方式：自然排序和定制排序。

TreeSet 可以通过 equals 或 CompareTo 方法判断两个对象是否相等。

自然排序要求元素实现 Comparable 接口的 CompareTo()方法。

定制排序要求元素实现 Comparator 接口的 compare 方法

  6、int和Integer的区别  

  7、==和equals的区别  

  8、final关键字  

  **9、接口和抽象类的区别**  

* 字段

  接口的字段修饰固定为 public, static, 和 final。接口不支持非静态和非 final 的变量。

  抽象类可以有非静态和非 final 的变量。

* 方法

  JDK8之后 ，接口中的方法可以有方法体。接口中也可以有静态的方法。抽象类的方法也可以有方法体。接口不支持非 final 的方法，但是抽象类支持 final 和 非 final 的方法，同时支持静态与非静态的方法。

* 构造器

  接口没有构造器；

  抽象类可以有任意数量的构造器；

* 成员访问权限

  接口中的所有成员默认都是 public 的， 接口不支持 private 和 protected。但是抽象类支持三种修饰符。

* 多重继承

  一个类仅可以继承一个抽象类，却可以实现多个接口。

使用场景：

以下场景考虑使用抽象类：

* 与几个亲密类共享代码；
* 继承抽象类的子类与抽象类有许多共同的方法或字段，或子类不需要父类的修饰符为 public 情况下；
* 想要声明非静态或非 final 的字段。

以下场景考虑使用接口：

* 无关的类会实现该接口，例如 Comparable 和 Cloneable 接口就被许多无关的类实现。
* 你想要指定该类型的特定行为，而不是考虑谁来实现这个行为。
* 想要利用多继承的优点。

  10、原子操作，CAS存在的问题，如何解决  

ABA问题，加版本号解决。

  11、++和--操作是否为原子操作，为什么  

不是，i++ 需要从内存中取出 i 的值，再自增1， 再存入内存。

  12、Java的异常处理机制，Error和Exception的区别  

在Java 中异常处理机制分为：抛出异常和捕捉异常。

**抛出异常：**当一个方法出现错误引发异常时，方法创建异常对象并交付运行时系统，**异常对象中包含了异常类型和异常出现时的程序状态等异常信息。**运行时系统负责寻找处置异常的代码并执行。

**捕获异常：**在方法抛出异常后，运行系统将转为寻找合适的异常处理器（Execption Handler）。**潜在的异常处理器是异常发生时依次存留在调用栈中的方法的集合。**当异常处理器所能处理的异常类型与方法抛出的异常类型相符时，即为合适的异常处理器。**运行时系统从发生异常的方法开始，依次回查调用栈中的方法，直至找到含有合适异常处理器的方法并执行。**当运行时系统遍历调用栈而未找到合适的异常处理器，则运行时系统终止。同时，Java程序终止。

**Error** ：是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误表示代码运行时 JVM 出现的问题。例如，Java 虚拟机运行错误，当JVM 所需要的内存资源不足时，会出现 OutOfMemoryErro。这些异常发生时，Java 虚拟机一般会选择线程终止。

**Exception：** 是程序本身可以处理的异常。例如空指针异常，除零异常或是数组越界异常。

  13、IOException需要捕获吗？  

  14、synchronized和Lock的区别  

  **15、线程池：创建、核心参数、拒绝策略**  

  16、Spring依赖注入的方式  

  17、当前bean有没有都行，应该采用什么方式注入  

  18、Redis的数据类型，常用的Redis命令  

  19、MyBatis中 # 和 $ 的区别  

  20、Mysql联合索引的最左匹配原则  

  21、项目相关，就让说了一下，没有深入的问

---





1、项目相关，遇到的难点，我说的比较笼统，后面又问了具体的困难和解决的方式  

  **2、TCP如何保证可靠传输，超时重传具体的时间和次数**  

1. 校验和

   TCP 报头中有对应的校验和字段， 目的是检测在传输过程中的任何变化， 如果收到的段的校验和有差错， TCP将丢弃这个报文和不确认收到此报文段。

2. 序列号和确认应答

   * TCP 给发送的每一个包进行递增编号，接收方对数据包进行排序，把有序的数据传递给应用层。
   * 接收方收到报文会进行确认应答。

3. 超时重传

   * 当TCP发出一个段后，会启动一个定时器， 等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。

4. 流量控制

   发送方有一个发送窗口，接收方有一个接收窗口。当接收方来不及处理发送方的数据时，会提示发送方降低发送速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。

5. 拥塞控制

   当网络拥塞时，减少数据的发送，防止包丢失。

  **3、Java的多态如何实现**  

JVM 方法调用的指令有五个,分别是:

invokestatic: 调用静态方法;

invokespecial:调用实例构造器<init>方法, 私有方法和父类方法;

**invokevirtual: 调用虚方法;**

invokeinterface: 调用接口方法, 运行时确定具体实现;

invokedynamic: 运行时动态解析所引用的方法,然后再执行,用于支持动态类型语言.

虚方法的分派有两种:一种是在编译期确定,被称为静态分派, 比如方法的重载; 一种是运行时确定,被称为动态分派, 比如方法的重写. 除 静态方法, 私有方法, 实例构造器, 父类方法外, 其余都是虚方法. 虚方法与 invokevirtual 指令有关.

多态的实现过程,就是方法调用动态分派的过程,通过栈帧的信息去找到被调用方法的具体实现, 然后使用这个具体实现的直接引用完成方法调用.

invokevirtual 指令的运行时解析过程大致分为以下几步:

1. 找到操作数栈顶的第一个元素所指向的对象的实际类型 class;
2. 找到class 中与被调用方法签名相同的方法,如果有访问权限就返回这个方法的直接引用,如果没有访问权限就报错;
3. 如果第2步找不到相符的方法,就去搜索 class 的父类,按照继承关系自下而上依次执行第2步的操作;
4. 如果始终找不到合适的方法,则报出异常.

上述过程保证了动态分派过程会首先确定实际类型是子类,从而先搜索到子类中的方法. 这个过程便是重写的本质.

虚拟机动态公派的实现: 虚拟机为了保证性能, 通常会使用虚方法表和接口方法表,而不是每次都执行一遍刚才的步骤. 以虚方法表为例 , 虚方法表在类加载的解析阶段填充完成, 其中存储了所有方法的直接引用. 也就 是说 动态分派在填充虚方法表的时候就已经完成了. 

在子类的虚方法表中,如果子类覆盖了父类的某个方法,则这个方法的直接引用指向子类的实现; 而子类没有覆盖的那些方法, 直接引用指向父类的实现.

  **4、线程池好处，创建方式，核心参数，实现原理**  

线程池的好处：

* 重用存在的线程， 减少线程创建，消亡的的开销， 提高性能。
* 提高响应速度， 当任务到达时， 任务可以不需要线程创建就能立即执行。
* 提高线程的可管理性， 可统一分配，调优和监控。

创建方式：

* 可以使用 `Executors.newFixedThreadPool(int nThreads)` 方式创建;

* 也可以使用 

`new ThreadPoolExecutor(2,3,60, TimeUnit.SECONDS,new ArrayBlockingQueue<Runnable>(5));`
创建。

  核心参数是：

* corePoolSize 核心线程数；
*  maximumPoolSize 最大线程数；
* keepAliveTime 非核心线程数空闲多久后消亡；
* 阻塞队列

实现原理：首先线程池由核心线程，非核心线程以及阻塞队列组成。线程池创建完成后，此时里面没有线程，当有任务过来时，会先创建核心线程来执行任务，当核心线程数达到最大值时，会将任务进阻塞队列，当阻塞队列满时，会创建非核心线程来执行到来的任务，当达到最大线程数时，会使用拒绝策略。有四种拒绝策略：

* AbortPolicy：丢弃任务并招聘 RejectedExecutionException 异常。这个是默认的策略。
* DiscardPolicy：丢弃任务，但不抛出异常。
* DiscardOldestPolicy：丢弃队列最前面的任务。
* CallerRunsPolicy：由调用线程（提交该任务的线程）处理该任务。

  

  **5、SQL注入**  

SQL 注入就是攻击者把SQL命令插入到Web 表单的输入域页面请求的查询字符串, 欺骗服务器执行恶意的SQL命令. 

造成SQL注入的原因:

程序没有有效过滤用户的输入,使攻击者成功的向服务器提交恶意的SQL脚本, 程序在接收后错误地将攻击者的输入作为SQL语句的一部分执行,导致原始的查询逻辑被改变, 执行了攻击者精心构造的恶意SQL语句. 

预防SQL注入攻击的方法

* 严格限制 Web 应用的数据库操作权限, 给连接数据库的用户提供满足需要的最低权限, 最大限度地减少注入攻击对数据库的危害.
* 校验参数的数据格式是否合法(可以使用正则表达式或特殊字符的判断);
* 对进入数据库的特殊字符进行转义处理, 或编码转换;
* 预编译SQL (Java 中使用 PreparedStatement), 参数化查询方式, 避免SQL拼接;
* 发布前,利用工具进行SQL注入检测;
* 报错信息不要包含SQL信息输出到Web页面.

  **6、幻读和不可重复读的区别**  

* 不可重复读的重点是修改: 在同一事务中, 同样的条件, 第一次读的数据和第二次读的数据不一样, 因为中间有其他事务提交了修改. 
* 幻读的重点在于新增行或删除行: 在同一事务中,同样的条件, 第一次和第二次读出来的记录数不一样. (因为中间有其他事务提交了插入或删除).

  **7、算法口述：数组中出现次数最多的前五个数**  

方法一: 使用HashMap 来统计元素出现次数, 再进行根据出现次数放入大根堆中进行排序;

方法二: 若数组中数的范围有限, 则可以利用桶排序来统计出现次数, 再对每个桶中的元素个数进行降序排序, 提取出前5个桶中的元素即可.

  **8、Servlet中forward和redirect的区别**  

redirect() 会丢失 request 的所有信息, 它属于页面级的重定向, 仅仅让你的浏览器重新访问一个新的URL, 作为浏览者, 能很明显的真的到浏览器URL地址的变化 , 这和点击了一个普通的超链接的后果是一样的.

而 RequestDispatcher 的 forward() 方法是转发, 需要 request 和 response 最为参数, 就是将用户的请求,连同请求信息等内容, 一起转发到服务器的另外一个 servlet 去处理, 它不会丢失 request 信息. 这一过程是服务器内部完成的, 作为访问者, 是感觉不到的, 或者说是透明的, 因此访客浏览器的 url 是不会发生变化的. 

forward 是转发, redirect 是跳转. 相同点都是为了两个组件之间的相互调用. forward 的运行原理是服务端内部的调用, 所以它不需要通过浏览器来请求, 所以 url 地址不会改变, request 的作用范围也没有中断过, 它的作用域仍然有效. 而 redirect 是重定向, 是服务器发送消息告诉浏览器, 让浏览器重新向新的地址请求, 所以, url 地址是会改变的, 由于重新请求了, 因而request 也中断了, 重新请求了, 它的作用范围也失效了, 放在 request 里面的信息也随之而清空了. 

  **9、UML相关的，类图、实例图之类的**  



  **10、红黑树知道吗？Java中什么集合底层实现是红黑树**