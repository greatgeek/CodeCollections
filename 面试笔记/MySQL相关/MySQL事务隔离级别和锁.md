# MySQL 事务隔离级别和锁

## 事务及其特性

事务拥有四个重要的特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability），人们习惯称之为 ACID 特性。

## 事务的隔离级别

![image-20200904160152475](MySQL事务隔离级别和锁.assets/image-20200904160152475.png)

## MySQL 中的锁

锁也是数据库**管理系统**区别文件系统的重要特征之一。**锁机制使得在对数据库进行并发访问时，可以保障数据的完整性和一致性。**对于锁的实现，各个数据库厂商的实现方法都会有所不同。本文讨论 MySQL 中的 InnoDB 引擎的锁。

### 锁的类型

InnoDB 实现了两种类型的行级锁：

- **共享锁** （也称为 S 锁）：允许事务读取一行数据。

  可以使用 SQL 语句 `select * from tableName where... lock in share mode;` 手动加 S 锁。

- **独占锁** （也称为 X 锁）：允许事务删除或更新一行数据。

  可以使用 SQL 语句 `select * from tableName where... for update`; 手动加 X 锁。

S 锁和 S 锁是 **兼容** 的，X 锁和其它锁都 **不兼容** ，举个例子，事务 T1 获取了一个行 r1 的 S 锁，另外事务 T2 可以立即获得行 r1 的 S 锁，此时 T1 和 T2 共同获得行 r1 的 S 锁，此种情况称为 **锁兼容** ，但是另外一个事务 T2 此时如果想获得行 r1 的 X 锁，则必须等待 T1 对行 r 锁的释放，此种情况也成为 **锁冲突** 。

为了实现多粒度的锁机制，InnoDB 还有两种内部使用的 **意向锁** ，由 InnoDB 自动添加，且都是表级别的锁。

- **意向共享锁** （IS）：事务即将给表中的各个行设置共享锁，事务给数据行加 S 锁前必须获得该表的 IS 锁。
- **意向排他锁** （IX）：事务即将给表中的各个行设置排他锁，事务给数据行加 X 锁前必须获得该表 IX 锁。

意向锁的主要目的是为了使得 **行锁** 和 **表锁** 共存。

![image-20200904160824000](MySQL事务隔离级别和锁.assets/image-20200904160824000.png)

### 行锁的算法

InnoDB 存储引擎使用三种行锁的算法用来满足相关事务隔离级别的要求。

- **Record Locks**

  该锁为索引记录上的锁，如果表中没有定义索引，InnoDB 会默认为该表创建一个隐藏的聚簇索引，并使用该索引锁定记录。

- **Gap Locks**

  该锁会锁定一个范围，但是不括记录本身。可以通过修改隔离级别为 `READ COMMITTED` 或者配置 `innodb_locks_unsafe_for_binlog` 参数为 `ON` 。

- **Next-key Locks**

  该锁就是 Record Locks 和 Gap Locks 的组合，即锁定一个范围并且锁定该记录本身。InnoDB 使用 Next-key Locks 解决幻读问题。需要注意的是，如果索引有唯一属性，则 InnnoDB 会自动将 Next-key Locks 降级为 Record  Locks。举个例子，如果一个索引有 1, 3, 5 三个值，则该索引锁定的区间为 `(-∞,1], (1,3], (3,5], (5,+ ∞)` 。

### 死锁

**死锁** 是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。

InnoDB 引擎采取的是 `wait-for graph` 等待图的方法来自动检测死锁，如果发现死锁会自动回滚一个事务。

### 锁的优化建议

锁如果利用不好，会给业务造成大量的卡顿现象，在了解了锁相关的一些知识点后，我们可以有意识的去避免锁带来的一些问题。

1. 合理设计索引，让 InnoDB 在索引键上面加锁的时候尽可能准确，尽可能的缩小锁定范围，避免造成不必要的锁定而影响其他 Query 的执行。
2. 尽可能减少基于范围的数据检索过滤条件，避免因为间隙锁带来的负面影响而锁定了不该锁定的记录。
3. 尽量控制事务的大小，减少锁定的资源量和锁定时间长度。
4. 在业务环境允许的情况下，尽量使用较低级别的事务隔离，以减少 MySQL 因为实现事务隔离级别所带来的附加成本。

## 参考

https://developer.ibm.com/zh/technologies/databases/articles/os-mysql-transaction-isolation-levels-and-locks/

