# RocketMQ —— ACK 机制保证消费成功

## ACK 简介

在实际使用 RocketMQ 的时候我们并不能保证每次发送的消息都刚好能被消费者一次性正常消费成功，可能会存在需要多次消费才能成功或者一直消费失败的情况，那作为发送者该做如何处理呢？

RocketMQ 提供了 ACK 机制，以保证消息能够被正常消费。发送者为了保证消息肯定消费成功，只有消费者明确表示消费成功，RocketMQ 才会认为消息消费成功。中途断电，抛出异常等都不会认为成功——即都会重新投递。

业务实现消费回调时，当且仅当回调函数返回 `ConsumeConcurrentlyStatus.CONSUME_SUCCESS`，`RocketMQ`才会认为这条消息是消费完成的。如果这时候消息消费失败，例如数据库 异常，余额不足扣款失败等业务认为消息需要重试的场景，只要返回 `ConsumeConcurrentlyStatus.RECONSUME_LATER`，`RocketMQ`就会认为这条消息消费失败了。

为了保证消息是肯定被成功消费的，`RocketMQ`会把这批消息重发回 `Broker`（ `topic`不是原 `topic`而是`RETRY topic`），在延迟的某个时间点后（默认是10秒）后，再次投递到这个 `ConsumerGroup`。而如果一直这样重复消费都持续失败到一定次数（默认 16 次），就会投递到 DLQ 死信 队列。应用可以监控死信队列来做人工干预。

## 定时拉取消息

`Push` 方式是 `Server` 端接收到消息后，主动把消息推送给 `Client` 端，实时性高。对于一个提供队列服务的 `Server`来说，用 `Push`方式主动推送有很多弊端：首先是加大 `Server` 端的工作量，进而影响 `Server` 的性能；其次，`Client` 的处理能力各不相同，`Client` 的状态不受 `Server`控制，如果 `Client` 不能及时处理 `Server` 推送过来的消息，会造成各种潜在的问题。

`Pull` 方式是 `Client` 端循环地从 `Server` 端拉取消息，主动权在 `Client` 手里，自己拉取到一定量消息后，处理妥当了再接着取。`Pull` 方式的问题是循环拉取消息的间隔不好设定，间隔太短的处在一个“忙等”的状态，浪费资源；每个 `Pull` 的时间间隔太长，`Server` 端有消息到来时，有可能没有被及时处理。