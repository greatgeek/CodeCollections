# 三维动态规划

其实不管是一维，二维，还是三维动态规划，都必须有一维是留给**阶段控制**的，还要设计结构来保存当前阶段的所有状态。每一个阶段都会以上一个阶段作为依据来进行更新。好了，来介绍今天的题目。

[**题目描述**](https://www.nowcoder.com/question/next?pid=20555525&qid=637400&tid=33776873)

  小v最近在玩一款挖矿的游戏，该游戏介绍如下： 

>    1、每次可以挖到多个矿石，每个矿石的重量都不一样，挖矿结束后需要通过一款平衡矿车运送下山；  
>
>    2、平衡矿车有左右2个车厢，中间只有1个车轮沿着导轨滑到山下，且矿车只有在2个车厢重量完全相等且矿石数量相差不超过1个的情况下才能成功运送矿石，否则在转弯时可能出现侧翻。   

  假设小v挖到了n（n<100）个矿石，每个矿石重量不超过100，为了确保一次性将n个矿石都运送出去，一旦矿车的车厢重量不一样就需要购买配重砝码。请问小v每次**最少**需要购买多少重量的砝码呢? （假设车厢足够放下这些矿石和砝码，砝码重量任选） 

##### **输入描述:**

```
输入n个正整数表示每个矿石的重量
```



##### **输出描述:**

```
输出一个正整数表示最少需要购买的砝码重量
```



##### **输入例子1:**

```
3 7 4 11 8 10
```



##### **输出例子1:**

```
1
```



##### **例子说明1:**

```
小v可以将重量3,7和11的矿石放到左车厢，重量4，8和10 放到右车厢，然后购买重量为1的砝码放到左车厢
```

## 分析（一）

题目可以抽象成一个背包问题，可以选择矿石装入背包（装入一个车厢），其余未装入背包的就是另外一份（另一个车厢）。

对于这个问题而言，我们还要记录放入背包的个数，还要记录背包达到的重量。别忘记还有一个变量需要记录，就是阶段控制。

由此我们便可以进行状态表示了：`f[i][j][k]` 是一个 `boolean`类型的数组，`i`表示当前处于第 `i` 阶段，`j` 表示背包中放入了 `j` 个矿石，`k`表示能达到的重量。

第`i`阶段代表选择第`i`个矿石，每个阶段的决策集只有两种：放入和不放入。

当矿石数量达到一半时，即可以进行计算所需要的平衡砝码。假设矿石数量达到一半时，放入背包的重量为 `x`， 则另一个车厢的重量可以得出`sum-x`（`sum` 为矿石总重量），则所需要的砝码重量为 `Math.abs(sum-x-x)`。在每一次符合要求的情况下取合法的最小砝码重量。

### talk is cheap , show me the code

```java
private static int func(int[] input){
        if(input.length==1) return input[0];
        int N=input.length;
        int sum=0;
        for(int x:input) sum +=x;
        int minWeight=Integer.MAX_VALUE;
        boolean[][][] f= new boolean[N+1][N+1][sum+1];
        f[0][0][0]=true;
        for(int i=1;i<=N;i++){ // 阶段控制
            int stone=input[i-1];
            /*
            * 将上一阶段的所有状态复刻到当前阶段，这其实已经对处于当前阶段的矿石作出了决策，就是不加入背包
            */
            for(int m=0;m<=N;m++){
                for(int n=0;n<=sum;n++){
                    f[i][m][n]=f[i-1][m][n];
                }
            }

            /*
            * 对当前阶段的矿石作出另一个决策，加入背包
            */
            for(int j=N;j>=1;j--){
                for(int k=sum;k>=stone;k--){
                    if(f[i][j-1][k-stone]) f[i][j][k]=true;
                    // 当背包中的矿石数达到一半时，求出所需砝码重量，并更新取最小值
                    if(j==N/2 && f[i][j][k]) minWeight=Math.min(Math.abs(sum-2*k),minWeight);
                }
            }
        }
        return minWeight;
    }
```



## 分析（二）

这的确是一个三维动态规划问题，不过我们可以不用将每一个阶段的状态都保存出来，当前阶段产生的更新直接覆盖上一个阶段即可，因此并不是每一个阶段的状态对我们都有用，我们需要的仅仅是当背包的矿石数达到一半时，求出砝码重量即可。这个也有一个**简单方便记忆的设计准则**：**进行状态表示设计时，要能完整表示当前阶段的状态；进行状态更新时，要能在上一个阶段的状态基础上进行更新，而不能当前阶段的状态更新将当前阶段的另一个更新覆盖。**

### talk is cheap , show me the code

```java
private static int func(int[] input){
        if(input.length==1) return input[0];
        int N=input.length;
        int sum=0;
        for(int x:input) sum +=x;
        int minWeight=Integer.MAX_VALUE;
        boolean[][] f= new boolean[N+1][sum+1];
        f[0][0]=true;
        for(int i=1;i<=N;i++){ // 阶段控制
            int stone=input[i-1];
            // 下面是每个阶段需要更新的内容，值得注意的是，当前阶段都是根据上一个阶段的内容作为依据来更新的
            for(int j=N;j>=1;j--){ // 使用逆序更新能保证不会出现当前阶段的更新状将当前阶段的另一个更新状态覆盖的问题
                for(int k=sum;k>=stone;k--){
                    if(f[j-1][k-stone]) f[j][k]=true;
                    if(j==N/2 && f[j][k]) minWeight=Math.min(Math.abs(sum-2*k),minWeight);
                }
            }
        }
        return minWeight;
    }
```

## 总结

其实在每一个动态规划问题中，阶段控制都必须占据一维，而剩下的维数则是当前阶段的状态表示。其中阶段控制的状态表示可以不出现在设计的状态表示中。